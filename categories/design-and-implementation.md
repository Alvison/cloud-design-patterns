### 设计和实现模式

良好的设计涵盖了如组件设计和部署中的一致性和相关性，简化管理和开发的可维护性，以及允许组件和子系统在其它应用程序和场景中的可重用性等因素。在设计和实施阶段做出的决策对托管在云商的应用程序和服务的质量、总体拥有成本产生巨大的影响。


| 模式                                       | 总结                               |
|------------------------------------------|----------------------------------|
| 大使模式(Ambassador)                         | 创建代表消费者服务或应用程序发送网络请求的帮助服务。       |
| 反腐模式(Anti-corruption Layer)              | 在现代应用程序和遗留系统之间实现装饰或适配器层。         |
| 前端专用的后端模式(Backends for Frontends)        | 创建单独的后端服务让特定的前端应用程序或接口使用。        |
| 命令和查询责任分离模式(CQRS)                        | 通过使用单独的接口来分离读取数据和更新数据的操作。|
| 计算资源整合模式(Compute Resource Consolidation) | 将多个任务或操作整合到单个计算单元中。|
| 外部配置存储(External Configuration Store)     | 将应用程序部署包中的配置信息移动到中心化的位置。 |
| 网关聚合模式(Gateway Aggregation)              |使用网关将多个单独的请求聚合到一个请求中。|
| 网关卸载模式(Gateway Offloading)               |卸载共享或特定的服务功能到网关代理。|
| 网关路由模式(Gateway Routing)                  |使用单个端点将请求路由到多个服务。 |
| 选举模式(Leader Election)                    | 通过选举一个实例作为负责管理其它实例的负责人，来协调分布式应用程序中的协作任务实例集合执行的操作。|
| 管道和过滤器模式(Pipes and Filters)              | 将需要执行复杂处理的任务分解成可以重复使用的一系列单独的元素。 |
| 挎斗模式(Side-Car)                           | 将应用程序的组件部署到单独的进程或容器中以提供隔离和封装。 |
| 静态内容托管模式(Static Content Hosting)         | 将静态内容部署到基于云的存储服务，可以将它们直接传递给客户端。 |
| 绞杀者模式(Strangler)                         | 通过使用新的应用程序和服务逐渐替换特定功能部件来逐步迁移旧系统。 |