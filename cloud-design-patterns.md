### 云设计模式

本书提到的设计模式对于在云中构建可靠，可扩展，安全的应用程序非常有用。
书中的每个模式描述了要解决的问题，使用模式的注意事项主要基于Microsoft Azure的例子。大多数模式包含如何在Azure上实现模式的代码示例或代码段。大多数模式都适用于分布式系统，具有普适性，和在那个云平台托管没有关系。

## 开发云上应用面临的挑战

### 可用性
可用性是系统正常工作时间的比例，通常以运行时间的百分比来衡量。它会受到系统错误，基础设施问题，恶意攻击和系统负载的影响。云应用程序通常会为用户提供服务等级协议（SLA），因此应用程序必须设计为最大限度地提高可用性。

### 数据管理

数据管理是云应用的关键要素，影响了大多数的质量属性。因为性能，可扩展性或可用性等原因，数据通常托管在不同的位置并跨多个服务器，这可能会带来一系列挑战。例如，必须保持数据一致性，并且数据通常需要在不同位置间同步。

### 设计和实现

良好的设计涵盖了如组件设计和部署中的一致性和相关性，简化管理和开发的可维护性，以及允许组件和子系统在其它应用程序和场景中的可重用性等因素。在设计和实施阶段做出的决策对托管在云上的应用程序和服务的质量、拥有者的总体成本产生巨大的影响。
 
### 消息

云应用程序的分布式特性需要一种连接组件和服务的消息基础设施，理想情况下松耦合，以便最大限度地提高可扩展性。异步消息系统使用广泛，提供了许多好处，但也带来了诸如消息排序，[毒药消息管理](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/poison-message-handling)，幂等等的挑战。

### 管理和监控

云应用程序运行在基础设施甚至操作系统无法完全控制的远程数据中心。管理和监控比本地部署更困难。应用程序必须公开管理员和操作员可以使用的运行时信息来管理和监视系统，以及支持不断变化的业务需求和定制，而不需要停止或重新部署应用程序。

### 性能和扩展性

性能是系统在给定时间间隔内执行任何操作的响应能力的指标，而可扩展性是系统处理增加的负载而不影响性能或轻松增加可用资源的能力。云应用程序工作负载通常是可变的并且存在活动高峰。预测这些，特别是在多租户场景中，几乎是不可能的。 相反，应用程序应能够在限制范围内扩展，以满足峰值需求，并在流量减少时缩小规模。可扩展性不仅涉及计算实例，还涉及数据存储，消息传递基础设施等其它元素。

### 弹性

弹性是系统优雅处理和恢复故障的能力。应用程序通常是多租户形式托管在云上，使用共享平台服务，竞争资源和带宽，通过互联网进行通信，在商业硬件上运行意味着出现短暂或永久性故障的可能性增加。检测故障和快速有效地恢复是保持弹性的必要条件。

### 安全

安全性是系统防止设计用途之外的恶意或意外行为的能力，并防止信息泄露或丢失。云应用程序暴露在互联网外的可信内部边界之外，通常向公众开放，并可能为不受信任的用户服务。 必须设计和部署应用程序，以防止其受到恶意攻击，限制仅对经过批准的用户的访问，并保护敏感数据。

## 模式目录
| 模式                                       | 总结                               |
|------------------------------------------|----------------------------------|
| 大使模式(Ambassador)                         | 创建代表消费者服务或应用程序发送网络请求的帮助服务。       |
| 反腐模式(Anti-corruption Layer)              | 在现代应用程序和遗留系统之间实现装饰或适配器层。         |
| 前端专用的后端模式(Backends for Frontends)        | 创建单独的后端服务让特定的前端应用程序或接口使用。        |
| 隔板模式(Bulkhead)                           | 将应用程序的元素隔离到池中，如果其中一个失败，其它的将继续运行。|
| 缓存?模式(Cache-Aside)                       | 按需将数据从数据存储加载到缓存中。|
| 断路器模式(Circuit Breaker)                   | 连接到远程服务或资源时, 处理可能需要花费时间来修复的故障。 |
| 命令和查询责任分离模式(CQRS)                        | 通过使用单独的接口来分离读取数据和更新数据的操作。|
| 补偿交易模式(Compensating Transaction)         |撤消通过一系列步骤执行的工作，它们一起定义最终一致的操作。|
| 竞争消费者模式(Competing Consumers)             |使用多个并发消费者来处理在同一消息通道上接收的消息。|
| 计算资源整合模式(Compute Resource Consolidation) | 将多个任务或操作整合到单个计算单元中。|
| 事件溯源模式(Event Sourcing)                   | 使用仅追加存储去记录描述对域中的数据采取的操作的完整系列事件。|
| 外部配置存储(External Configuration Store)     | 将应用程序部署包中的配置信息移动到中心化的位置。 |
| 联合身份模式(Federated Identity)               |将认证委托给外部身份提供者。|
| 看门人模式(Gatekeeper)                        |  通过使用专用主机实例，充当客户端和应用程序或服务之间的代理，来保护应用程序和服务，该主机实例，对请求进行验证和消毒，并在它们之间传递请求和数据。|
| 网关聚合模式(Gateway Aggregation)              |使用网关将多个单独的请求聚合到一个请求中。|
| 网关卸载模式(Gateway Offloading)               |卸载共享或特定的服务功能到网关代理。|
| 网关路由模式(Gateway Routing)                  |使用单个端点将请求路由到多个服务。 |
| 健康端点监控模式(Health Endpoint Monitoring)     |在应用程序中执行功能检查，外部工具可以定期通过暴露的端点访问。|
| 索引表模式(Index Table)                       |为查询经常引用的数据存储区中的字段创建索引。|
| 选举模式(Leader Election)                    | 通过选举一个实例作为负责管理其它实例的负责人，来协调分布式应用程序中的协作任务实例集合执行的操作。|
| 物化视图模式(Materialized View)                |针对所需的查询操作，当数据没有理想地格式化时，在一个或多个数据存储中的数据上生成预填充视图。|
| 管道和过滤器模式(Pipes and Filters)              | 将需要执行复杂处理的任务分解成可以重复使用的一系列单独的元素。 |
| 优先级队列模式(Priority Queue)                  | 确定发送到服务的请求的优先级，使得具有较高优先级的请求更快地被接收和处理。|
| 基于队列的负载均衡模式(Queue-Based Load Leveling)   | 使用一个队列作为任务和服务之间的缓冲区，平滑间歇性重负载。|
| 重试模式(Retry)                              | 在应用程序尝试连接到服务或网络资源遇到预期的临时故障时，让程序通过透明地重试以前失败的操作来处理。|
| 调度代理主管模式(Scheduler Agent Supervisor)     | 在一组分布式服务和其它远程资源之间协调一组操作。|
| 分片模式(Sharding))                          | 将数据存储区划分为一组水平分区或分片。 |
| 挎斗模式(Side-Car)                           | 将应用程序的组件部署到单独的进程或容器中以提供隔离和封装。 |
| 静态内容托管模式(Static Content Hosting)         | 将静态内容部署到基于云的存储服务，可以将它们直接传递给客户端。 |
| 绞杀者模式(Strangler)                         | 通过使用新的应用程序和服务逐渐替换特定功能部件来逐步迁移旧系统。 |
| 限流模式(Throttling)                         | 控制应用程序，个人租户或整个服务的实例消耗的资源。 |
| 代客密钥模式(Valet Key)                    |使用向客户端提供对特定资源或服务的有限直接访问权限的令牌或密钥。|
